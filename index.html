<!DOCTYPE html>
<html>
  <!-- STEP 1: Prepare the canvas -->
  <head>
    <style>
      #my_Canvas {
        border: 0px dotted blue;
      }
      body,
      html {
        overflow: hidden;
      }
    </style>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <script type="text/javascript" src="dat.gui.min.js"></script>
    <script src="gl-matrix-min.js"></script>
  </head>

  <body>
    <!-- Mostramos el marcador-->
    <div id="collision">Colision: 0</div>
    <canvas style="width: 95%" width="500" height="500" id="my_Canvas"></canvas>

    <!-- vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
      #version 300 es
      precision mediump float;

      in vec3 aCoordinates;
      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;

      void main(void) {
        gl_Position = uViewMatrix * uModelMatrix * vec4(aCoordinates, 1.0);
        gl_PointSize = 10.0;
        //gl_Position.z *= -1.0;
      }
    </script>

    <!-- fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        out vec4 fragColor;
        uniform vec4 uColor;

        void main(void) {
          fragColor = uColor;
      }
    </script>

    <script>
      const { vec2, vec3, mat3, mat4 } = glMatrix;

      var player = {
        x: 0,
        y: 0.5,
        z: 10,
        ori: -Math.PI / 2,
      };

      var gl;
      var canvas;
      var vertex_buffer;
      var colorLocation;
      var index_buffer;

      var rotateX = 0,
        rotateY = 0;
      var mouseX, mouseY;
      var zoomFactor = 1;
      var viewMatrixLoc, modelMatrixLoc;

      var cube1PositionX = -3; // Posición inicial del primer cubo
      var cube2PositionX = 3; // Posición inicial del segundo cubo

      var bullets = []; // Arreglo para almacenar los disparos

      var collision = 0; // Variable para mantener la puntuación

      var matrixStack = [];

      //Una función para actualizar el marcador
      function updateScore() {
        const collisionElement = document.getElementById("collision");
        collisionElement.textContent = "Colision: " + collision;
      }

      function glPushMatrix() {
        const matrix = mat4.create();
        mat4.copy(matrix, modelMatrix);
        matrixStack.push(matrix);
      }

      function glPopMatrix() {
        modelMatrix = matrixStack.pop();
      }

      function drawSquare() {
        v = new Float32Array([
          -0.5, 0.5, 0.5, 0.5, -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5,
        ]);
        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      function init() {
        // ============ STEP 1: Creating a canvas=================
        canvas = document.getElementById("my_Canvas");
        gl = canvas.getContext("webgl2");

        //========== STEP 2: Create and compile shaders ==========

        // Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        // Attach vertex shader source code
        var script = document.getElementById("vertex-shader");
        var shaderString = script.text.trim();
        gl.shaderSource(vertShader, shaderString);

        // Compile the vertex shader
        gl.compileShader(vertShader);

        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        script = document.getElementById("fragment-shader");
        shaderString = script.text.trim();
        gl.shaderSource(fragShader, shaderString);

        // Compile the fragmentt shader
        gl.compileShader(fragShader);

        // Create a shader program object to store
        // the combined shader program
        var shaderProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both programs
        gl.linkProgram(shaderProgram);

        // Use the combined shader program object
        gl.useProgram(shaderProgram);

        //======== STEP 3: Create buffer objects and associate shaders ========

        // Create an empty buffer object to store the vertex buffer
        vertex_buffer = gl.createBuffer();
        index_buffer = gl.createBuffer();

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Get the attribute location
        var coordLocation = gl.getAttribLocation(shaderProgram, "aCoordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coordLocation, 3, gl.FLOAT, false, 0, 0);

        // look up uniform locations
        colorLocation = gl.getUniformLocation(shaderProgram, "uColor");

        modelMatrixLoc = gl.getUniformLocation(shaderProgram, "uModelMatrix");

        viewMatrixLoc = gl.getUniformLocation(shaderProgram, "uViewMatrix");

        // Enable the attribute
        gl.enableVertexAttribArray(coordLocation);
        gl.enable(gl.DEPTH_TEST);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        render();
      }

      function render(time) {
        // Clear the canvas
        gl.clearColor(0.9, 1, 1, 1.0);

        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);

        // aquí renderizamos la escena
        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);

        // perspectiva
        viewMatrix = mat4.create();
        mat4.perspective(viewMatrix, Math.PI / 4, 1, 1, 30);
        gl.uniformMatrix4fv(viewMatrixLoc, false, viewMatrix);
        //mat4.lookAt(modelMatrix, [0, 0.5, 10], [0, 0.5, 0], [0, 1, 0]);

        eye = [player.x, player.y, player.z];
        v = [
          player.x + Math.cos(player.ori),
          player.y,
          player.z + Math.sin(player.ori),
        ];
        mat4.lookAt(modelMatrix, eye, v, [0, 1, 0]);

        //mouse rotations
        mat4.rotateX(modelMatrix, modelMatrix, rotateX);
        mat4.rotateY(modelMatrix, modelMatrix, rotateY);

        // transformaciones GUI y ratón
        mat4.scale(modelMatrix, modelMatrix, [
          zoomFactor,
          zoomFactor,
          zoomFactor,
        ]);
        mat4.rotateX(modelMatrix, modelMatrix, rotateX);
        mat4.rotateY(modelMatrix, modelMatrix, rotateY);

        // Renderiza los cubos con posiciones actualizadas
        glRenderCubeIBO(cube1PositionX, 0, 2, [1, 0, 1, 1], [1, 1, 1]);
        glRenderCubeIBO(cube2PositionX, 0, 0, [0, 1, 1, 1], [1, 1, 1]);
        glRenderGround(8, 10);

        // Movimiento de las balas
        for (let i = 0; i < bullets.length; i++) {
          const bullet = bullets[i];
          bullet.x += Math.cos(bullet.ori) * 0.1;
          bullet.z += Math.sin(bullet.ori) * 0.1;
          drawBullet(bullets[i]);
        }

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        // Actualiza las posiciones de los cubos (izquierda a derecha)
        cube1PositionX += 0.1; // Puedes ajustar la velocidad
        cube2PositionX -= 0.1; // Puedes ajustar la velocidad

        // Asegúrate de que los cubos no se salgan del rango del suelo
        if (cube1PositionX > 4) {
          cube1PositionX = -4;
        }
        if (cube2PositionX < -4) {
          cube2PositionX = 4;
        }

        // Miramos si hay colisiones
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          if (checkCollision(bullet)) {
            bullets.splice(i, 1);
            collision++; // Incrementa la puntuación si hay una colision
            updateScore(); // Actualiza el marcador en el HTML
          } else if (bullet.y < 0 || bullet.z < -10) {
            bullets.splice(i, 1);
          }
        }

        // empezamos bucle animación
        window.requestAnimationFrame(render);
      }

      function glRenderCubeIBO(x, cubePositionY, z, color, size) {
        glPushMatrix();
        mat4.translate(modelMatrix, modelMatrix, [x, cubePositionY, z]);

        // Escala el cubo
        mat4.scale(modelMatrix, modelMatrix, size);

        gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);

        // create vertices
        arrayV = new Float32Array([
          0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1,
          1,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, arrayV, gl.STATIC_DRAW);

        // draw edges
        arrayI = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]);

        // draw faces
        arrayF = new Uint16Array([
          4, 5, 6, 0, 3, 2, 2, 1, 0, 4, 6, 7, 7, 6, 2, 7, 2, 3, 5, 4, 0, 0, 1,
          5, 1, 2, 6, 1, 6, 5, 0, 4, 7, 7, 3, 0,
        ]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayF, gl.STATIC_DRAW);
        gl.uniform4fv(colorLocation, color);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayI, gl.STATIC_DRAW);
        gl.uniform4fv(colorLocation, [0, 0, 0, 1]);
        gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 0);

        delete arrayV;
        delete arrayI;
        glPopMatrix();
      }

      // draw squared floor
      function glRenderGround(size, n) {
        glPushMatrix();
        mat4.scale(modelMatrix, modelMatrix, [size, size, size]);
        mat4.translate(modelMatrix, modelMatrix, [-0.5, 0, -0.5]);
        gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
        // creamos vector vértices
        k = 0;
        arrayV = new Float32Array(12 * n);
        for (i = 0; i < n; i++) {
          arrayV[k++] = i / (n - 1);
          arrayV[k++] = 0;
          arrayV[k++] = 0;
          arrayV[k++] = i / (n - 1);
          arrayV[k++] = 0;
          arrayV[k++] = 1;
        }
        for (i = 0; i <= n; i++) {
          arrayV[k++] = 0;
          arrayV[k++] = 0;
          arrayV[k++] = i / (n - 1);
          arrayV[k++] = 1;
          arrayV[k++] = 0;
          arrayV[k++] = i / (n - 1);
        }
        gl.bufferData(gl.ARRAY_BUFFER, arrayV, gl.STATIC_DRAW);
        gl.drawArrays(gl.LINES, 0, 4 * n);
        delete arrayV;
        glPopMatrix();
      }

      // Dibujamos la forma de la bala
      function drawBullet(bullet) {
        glPushMatrix();
        mat4.translate(modelMatrix, modelMatrix, [
          bullet.x,
          bullet.y,
          bullet.z,
        ]);

        mat4.rotateY(modelMatrix, modelMatrix, bullet.ori);

        mat4.scale(modelMatrix, modelMatrix, [1, 1, 1]);

        gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);

        glRenderCubeIBO(0, 0, 0, [1, 0, 0, 1], [0.5, 0.5, 0.5]);

        glPopMatrix();
      }

      // Comprobamos si en algun momento la bala choca con un cubo
      function checkCollision(bullet) {
        for (var i = 0; i < 2; i++) {
          var cubeX = i === 0 ? cube1PositionX : cube2PositionX;
          var cubeY = 0;
          var cubeZ = i === 0 ? 2 : 0;
          var cubeSize = 1;

          if (
            bullet.x + 0.5 * 0.5 > cubeX - 0.5 * cubeSize &&
            bullet.x - 0.5 * 0.5 < cubeX + 0.5 * cubeSize &&
            bullet.y + 0.5 * 0.5 > cubeY - 0.5 * cubeSize &&
            bullet.y - 0.5 * 0.5 < cubeY + 0.5 * cubeSize &&
            bullet.z + 0.5 * 0.5 > cubeZ - 0.5 * cubeSize &&
            bullet.z - 0.5 * 0.5 < cubeZ + 0.5 * cubeSize
          ) {
            console.log("Colision detectada con el cubo " + i);
            return true;
          }
        }
      }

      function onKeyDown(key) {
        switch (key.keyCode) {
          // up arrow
          case 38: {
            player.x = player.x + 0.1 * Math.cos(player.ori);
            player.z = player.z + 0.1 * Math.sin(player.ori);
            break;
          }
          // down arrow
          case 40: {
            player.x = player.x - 0.1 * Math.cos(player.ori);
            player.z = player.z - 0.1 * Math.sin(player.ori);
            break;
          }
          // left arrow
          case 37: {
            player.ori -= 0.02;
            break;
          }
          // down arrow
          case 39: {
            player.ori += 0.02;
            break;
          }
          // Space bar to shoot
          case 32: {
            shoot();
            break;
          }
        }
      }

      function shoot() {
        var bullet = {
          x: player.x,
          y: player.y,
          z: player.z,
          ori: player.ori,
        };
        bullets.push(bullet);
        console.log("Disparo realizado");
      }

      function onMouseDown(e) {
        if (e.buttons == 1 && e.srcElement == canvas) {
          mouseX = e.pageX;
          mouseY = e.pageY;
        }
      }

      function onMouseMove(e) {
        if (e.buttons == 1 && e.srcElement == canvas) {
          rotateY = rotateY + (e.pageX - mouseX) * 0.01;
          rotateX = rotateX + (e.pageY - mouseY) * 0.01;
          mouseX = e.pageX;
          mouseY = e.pageY;
          //console.log("move = ("+mouseX+","+mouseY+")");
        }
      }

      function zoom(e) {
        if (e.deltaY < 0) zoomFactor *= 1.1;
        else zoomFactor *= 0.9;
      }

      window.onload = init;
      document.onmousedown = onMouseDown;
      document.onmousemove = onMouseMove;
      document.onwheel = zoom;
      document.onkeydown = onKeyDown;
    </script>
  </body>
</html>
